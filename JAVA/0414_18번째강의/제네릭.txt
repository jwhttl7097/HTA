Book, Computer, Phone객체를 저장하는 설계도 만들기
1. Book, Computer, Phone 타입의 멤버변수가 정의된 클래스를 3개 정의한다.
   class BookBox {
      Book book;
   }

   class ComputerBox {
      Computer Computer;
   }

   class PhoneBox {
      Phone phone;
   }

2. Book, Computer, Phone 객체를 모두 수용할 수 있는 Object타입의 멤버변수를 정의한다.
   class Box {
      private Object item;
      public void setItem(Object item) { this.item = item; }
      public Object getItem() { return item; }
   }
   // 생성된 Box 객체에 특정 타입의 객체만 저장되게 제약을 할 수 없다.
   // Phone객체만 담는 박스를 생성했지만, Computer객체가 저장되는 것을 막을 수 없다.(컴파일시 체크가 되지 않는다.)
   Box box = new Box();   
   box.setItem(new Phone());
   box.setItem(new Computer());

   // Box에서 저장된 객체를 꺼내면 실제 저장한 객체의 주소값 대신 Object타입의 주소값이 반환된다.
   // 따라서, Box에 저장된 객체를 꺼낼때마다 클래스 형변환을 해야 된다. 
   Phone p = (Phone) box.getItem();

3. Book, Computer, Phone 객체 중 어느 객체를 저장할 지 미리 정하지 말고,
   일단 별칭만 지정해 준 다음, 객체 생성싯점에 정확한 타입을 지정하자.
   // 설계도
   class Box<T> {
      private T item;
      public void setItem(T item) {
         this.item = item;
      }
      public T getItem() {
         return item;
      }
   }

   Box<Phone> box = new Box<Phone>();
   box.setItem(new Phone());
   box.setItem(new Computer());   // 이클립스에서 에러표시

   Phone p = box.getItem();   // 형변환 연산 필요없음

   // 실제로 생성된 객체
   class Box<Phone> {
      private Phone item;
      public void setItem(Phone item) {
         this.item = item;
      }
      public Phone getItem() {
         return item;
      }
   }

   
* 제네릭 
   - 정의
      - 클래스 내부에서 사용할 데이터 타입을 소스코드에서 지정하지 않고,
             클래스 외부에서 지정하는 기법이다.
      - 소스코드에서는 
                  public class 클래스명<타입파라미터> { 
         타입파라미터 변수;
        }
        와 같은 형식으로 설계한다.
        * 타입파라미터는 보통 영어 대문자를 사용한다.
                  * 타입파라미터는 1개 이상 지정할 수 있다.
        * 객체 생성시 타입파라미터의 위치에 실제로 사용할 타입을 지정하면 생성된 객체는 해당 타입으로
                    변경되어 있다. 
   - 목적
      - 배열처럼 다양한 타입의 객체를 다루는 클래스를 설계할 때 사용한다.
      - 자바에서는 객체를 여러개 저장하는 콜렉션 클래스들이 대표적인 예다.
          ArrayList<E>, HashSet<E>, TreeSet<E>, Stack<E>, Vector<E>,
             LinkedList<E>
   - 장점
      - 타입파라미터로 지정한 타입의 객체만 저장된다.(타입안정성)
      - 어떤 타입의 객체를 저장할 목적으로 생성했는지 바로 파악이 가능하다.(코드 가독성 증가)
      - 프로그램 실행 전, 컴파일 과정에서 타입오류가 체크된다.
      - 형변환의 번거로움이 사라진다.
   - 사용예
      ArrayList<Product> products = new ArrayList<Product>();
      ArrayList<Order> orders = new ArrayList<Order>();
      ArrayList<Book> books = new ArrayList<Book>();
      HashSet<Team> teams = new HashSet<Tema>();
      
